// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
  // Further reading:
  // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
  // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
}

// ENUMS

enum EventStatus {
  ACTIVE
  ENDED
  UPCOMING
}

enum UserRole {
  ADMIN
  USER
}

enum ActivityType {
  GIFTING // The "Love Feast"
  TRIVIA
  SCAVENGER
  POLLS
  ICEBREAKER
}

enum ActivityStatus {
  PENDING
  ACTIVE
  COMPLETED
}

//MODELS
model Event {
  id          String      @id @default(cuid())
  title       String
  description String?     @db.Text
  location    String?
  date        DateTime
  slug        String      @unique // The unique part of the URL (e.g., 'friday-games-xyz')
  status      EventStatus @default(UPCOMING)

  // Ownership
  creatorId String
  creator   User   @relation("EventCreator", fields: [creatorId], references: [id])

  // Relations

  activities   Activity[] // An event can have many activities
  participants Participant[]
  // teams        Team[]
  // matches      Match[]
  // matchHistory MatchHistory[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([creatorId])
}

model Participant {
  id      String @id @default(cuid())
  userId  String
  eventId String

  // This is where the event-specific wishlist lives!
  wishlist String? @db.Text

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  givingTo      Match[] @relation("Giver")
  receivingFrom Match[] @relation("Receiver")

  joinedAt DateTime @default(now())

  // Critical: A user can only be a participant in an event once
  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
}

model Activity {
  id     String         @id @default(cuid())
  type   ActivityType
  status ActivityStatus @default(PENDING)

  // Settings is a JSON field. Why? 
  // Because Gifting needs "budget", Trivia needs "questions", etc.
  settings Json?

  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  // For Gifting/Love Feast specifically
  matches Match[]

  createdAt DateTime @default(now())
}

model Match {
  id         String   @id @default(cuid())
  activityId String
  activity   Activity @relation(fields: [activityId], references: [id])

  giverId    String
  receiverId String

  giver    Participant @relation("Giver", fields: [giverId], references: [id])
  receiver Participant @relation("Receiver", fields: [receiverId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([activityId, giverId])
  @@unique([activityId, receiverId])
}

// enum MatchStatus {
//   PENDING
//   ACCEPTED
//   COMPLETED
// }

// model MatchHistory {
//   id             String   @id @default(cuid())
//   eventId        String
//   giverUserId    String
//   receiverUserId String
//   matchedAt      DateTime @default(now())
//   attemptNo      Int // Track which attempt this was, for sorting
//   event          Event    @relation(fields: [eventId], references: [id])

//   receiver User @relation(fields: [receiverUserId], references: [id])

//   @@index([eventId, giverUserId])
// }

// Necessary for Next auth
model Account {
  id                       String  @id @default(cuid())
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String? @db.Text
  access_token             String? @db.Text
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String? @db.Text
  session_state            String?
  user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  refresh_token_expires_in Int?

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String        @id @default(cuid())
  firstName     String?
  lastName      String?
  username      String?       @unique
  password      String?
  // gender        String?
  email         String?       @unique
  emailVerified DateTime?
  /// @param loginCount - This is a hack we increment upon login
  loginCount    Int           @default(0)
  image         String?
  role          UserRole      @default(USER)
  /// @param bio - a string users can use to write their wishlist
  /// during event participation, we simply copy bio into participant.wishlist
  // bio           String?
  accounts      Account[]
  sessions      Session[]
  createdEvents Event[]       @relation("EventCreator")
  participating Participant[]

  /// @param matchHistory - Where a user has been matched as a receiver
  /// reference is @receiverUserId in MatchHistory model.
  // matchHistory MatchHistory[]
}

model VerificationToken {
  id         String   @id @default(cuid())
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model PasswordResetToken {
  id         String   @id @default(cuid())
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
